= pbar - A simple Progress bar for Go
:toc:

pbar is a simple progress bar for Go.
It's centered around the idea that you are probably iterating over a set of operations, and displays:

+++<a href="https://pkg.go.dev/github.com/meagar/pbar"><img src="https://pkg.go.dev/badge/github.com/meagar/pbar.svg" alt="Go Reference"></a>+++

[source]
263094 of 8635491 (3%) - OPS: 2009.81 - ETA: 1h9m25s [=---------------------------------]

The fields are (left to right):

* Your progress against the total operations (`x of y`)
* The completion rate (`x%`)
* Your average operations per second (`OPS:`)
* The estimated time remaining (`ETA:`)
* A progress bar that scales to the width of the terminal

== Usage

1. Create a new bar with `pbar.New`, passing in the total number of records and (optionally) the maximum width of the bar, in case you don't want it to span the whole window. This is useful if the non-portal method used to get the terminal width fails on your platform.
+
[source,go]
----
bar := pbar.New({
        Total: 1000,
})
----

2. Call `bar.Tick()` and pass in the current progress through your set of operations. You can call this inside a loop after each operation, or periodically each time you hit a specific number of records, or in a timer with `time.After` (See examples below).
+
Internally `Tick` will measure the amount of time since the last call to `Tick` to determine the average operations-per-second

3. Call `fmt.Print(bar.Progress())` to display the progress bar

4. After completion, call `bar.Summary()` to display the total elapsed time.

== Examples

=== A simple `for` loop:

You can display the progress of an arbitrary `for` loop:

[source,go]
----
bar := pbar.New({
        Total: 1000,
})

for i := 0; i < 10000; i++ {

        someFunc(i)

        if i % 1000 == 0 {
                // Only redraw the bar once every 1000 operations
                bar.Tick(1000)
                fmt.Print(bar.Progress())
        }
}

fmt.Println(bar.Summary())
----

This couples the redraw rate of the progress bar to the rate at which your batches are processed.
This might be more *or* less frequent than you desire; redrawing too frequently wastes CPU cycles, and redrawing to infrequently makes the progress bar appear frozen.

To address this, `Tick()` and `Progress()` are independent operations, decoupling redrawing the bar from timing the underlying operation.
You can make the `for` loop and `Tick` call asynchronous and use a `select` with `time.After` to output `bar.Progress()` on a regular interval:

[source,go]
----
bar := pbar.New({
        Total: 1000,
})

done := make(chan bool)

go func() {
        for i := 0; i < 10000; i++ {
                someFunc(i)

                if i % 100 == 0 {
                        bar.Tick(100)
                }
        }
        done <- true
}()

progress:
for {
        select {
        case <-done
                break progress
        case time.After(time.Second)
                // Redraw the progress bar every 1 second, regardless of how frequently Tick is called
                fmt.Print(bar.Progress())
        }
}

fmt.Println(bar.Summary())
----

=== Gorm's `FindInBatches`

Gorm's `FindInBatches` is a more realistic usecase:

[source,go]
----

func ProcessRecords() {
        // Retrieve the total number of records to process
        count := 0
        db.Model(&Post).Count(&count)

        bar := pbar.New({
                Total: count
        })

        done := make(chan bool)
        go func() {
                var results []Post
                db.FindInBatches(&results, 1000, func(tx *gorm.DB, batch int) error {
                        processResults(results)

                        bar.Tick(1000)

                        return nil
                })
                done <- true
        }()

        for {
                select {
                case <-time.After(time.Duration(0.5 * float64(time.Second))):
                        // Redraw the bar every two seconds
                        fmt.Print(bar.Progress())
                case <- done
                        fmt.Println(bar.Summary())
                        return
        }
}
----